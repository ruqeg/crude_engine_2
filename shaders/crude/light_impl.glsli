
#ifndef CRUDE_LIGTH_CALCULATION_GLSLI
#define CRUDE_LIGTH_CALCULATION_GLSLI

#if defined( LIGHT_PBR ) || defined( TRANSPARENT_NO_CULL )  // !TODO bad, but it works

CRUDE_UNIFORM( SceneConstant, 0 ) 
{
  crude_scene                                              scene;
};

CRUDE_RBUFFER( ZBins, 10 ) 
{
  uint                                                     bins[];
};

CRUDE_RBUFFER( Lights, 11 ) 
{
  crude_light                                              lights[];
};

CRUDE_RBUFFER( Tiles, 12 ) 
{
  uint                                                     lights_tiles[];
};

CRUDE_RBUFFER( LightIndices, 13 ) 
{
  uint                                                     lights_indices[];
};

CRUDE_RBUFFER( ShadowViews, 14 )
{
  mat4                                                      pointlight_world_to_clip[];
};

#if defined( CRUDE_STAGE_FRAGMENT )

float
crude_calculate_point_light_shadow_contribution
(
  in crude_light                                           light,
  in vec3                                                  vertex_position
)
{
#ifdef CRUDE_RAYTRACED_SHADOWS
  rayQueryEXT                                              ray_query;
  float                                                    vertex_to_light_distance;
  vec3                                                     vertex_to_light, vertex_to_light_normalized;

  vertex_to_light = light.world_position - vertex_position.xyz;
  vertex_to_light_distance = length( vertex_to_light );
  vertex_to_light_normalized = vertex_to_light / vertex_to_light_distance;

  float visiblity = 0.f;
  if ( vertex_to_light_distance <= light.radius )
  {
    rayQueryInitializeEXT( ray_query, acceleration_structure, gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT, 0xff, vertex_position, 0.05, vertex_to_light_normalized, vertex_to_light_distance );
    rayQueryProceedEXT( ray_query );
    visiblity = float( rayQueryGetIntersectionTypeEXT( ray_query, true ) == gl_RayQueryCommittedIntersectionNoneEXT );
  }
  return visiblity;
#else /* CRUDE_RAYTRACED_SHADOWS */
  vec4                                                     proj_pos;
  vec3                                                     vertex_to_light;
  vec2                                                     proj_uv, filter_radius;
  uint                                                     face_index;
  float                                                    bias, current_depth, shadow_factor;

  vertex_to_light = light.world_position - vertex_position.xyz;
  face_index = crude_get_tetrahedron_face_index( normalize( -vertex_to_light ) );
  proj_pos = vec4( vertex_position.xyz, 1.0 ) * pointlight_world_to_clip[ 0 * 4 + face_index ];
  proj_pos.xyz /= proj_pos.w;
    
  proj_uv = ( proj_pos.xy * 0.5 ) + 0.5;
  proj_uv.y = 1.f - proj_uv.y;

  bias = 0.003f;
  current_depth = proj_pos.z;
    
  filter_radius = scene.inv_shadow_map_size.xy * CRUDE_SHADOW_FILTER_RADIUS; 
  
  shadow_factor = 0;
  for ( uint i = 0; i < CRUDE_SHADOW_FILTER_NUM_SAMPLES; ++i )
  {
    vec2 texcoords = proj_uv.xy + ( filter_kernel[i] * filter_radius );
    float closest_depth = texture( global_textures[ nonuniformEXT( scene.tiled_shadowmap_texture_index ) ], texcoords ).r;
    shadow_factor += current_depth - bias < closest_depth ? 1 : 0;
  }

  return shadow_factor / CRUDE_SHADOW_FILTER_NUM_SAMPLES;
#endif /* CRUDE_RAYTRACED_SHADOWS */
}

vec3
crude_calculate_point_light_contribution
(
  in crude_light                                           light,
  in vec3                                                  albedo,
  in float                                                 roughness,
  in float                                                 metalness,
  in vec3                                                  normal,
  in vec3                                                  vertex_position,
  in vec3                                                  camera_position,
  in vec3                                                  f0
)
{
  vec3                                                     indirect_irradiance, indirect_diffuse, light_to_position, l, radiance, f, spec, diff, h, v;
  float                                                    light_distance, ndotl, ndoth, ndotv, hdotl;

  roughness = 0.2;
  light_to_position = light.world_position - vertex_position;
  light_distance = length( light_to_position );

  l = light_to_position / light_distance;
  v = normalize( camera_position - vertex_position );
  h = normalize( l + v );

  ndotl = dot( normal, l );
  ndoth = dot( normal, h );
  ndotv = dot( normal, v );
  hdotl = dot( h, l );

  radiance = light.color * light.intensity * crude_light_attenuation( light_distance, light.radius );

  f = crude_schlick_fresnel( f0, hdotl );
  spec = f * crude_trowbridge_reitz_distribution( ndoth, roughness * roughness ) * crude_hammon_smith_g_approximation( abs( ndotl ), abs( ndotv ), roughness ); /* in case i will be confused in the future, crude_hammon_smith_g_approximation already contains /4ndotlndotv (real time rendering p342) */
  diff = ( 1.f - f ) * albedo / PI;
  return radiance * max( ndotl, 0.f ) * ( diff + spec );
}

vec3
crude_calculate_lighting
(
  in vec4                                                  albedo,
  in float                                                 roughness,
  in float                                                 metalness,
  in vec3                                                  normal,
  in vec3                                                  vertex_position,
  in vec3                                                  camera_position,
  in uvec2                                                 position,
  in vec2                                                  screen_texcoord
)
{
  vec4                                                     view_position;
  vec3                                                     radiance, indirect_irradiance, indirect_diffuse;
  uvec2                                                    tile;
  float                                                    linear_d;
  int                                                      bin_index;
  uint                                                     bin_value, min_light_id, max_light_id, stride, address;

  vec3 f0 = vec3( 0.04f );

  radiance = vec3( 0 );

  view_position = vec4( vertex_position, 1.0 ) * scene.camera.world_to_view;

  linear_d = ( view_position.z - scene.camera.znear ) / ( scene.camera.zfar - scene.camera.znear );
  bin_index = int( linear_d * CRUDE_LIGHT_BINS_COUNT );
  bin_value = bins[ bin_index ];

  min_light_id = bin_value & 0xFFFF;
  max_light_id = ( bin_value >> 16 ) & 0xFFFF;

  tile = position / uint( CRUDE_LIGHT_TILE_SIZE );

  stride = uint( CRUDE_LIGHT_WORDS_COUNT ) * ( uint( scene.resolution.x ) / uint( CRUDE_LIGHT_TILE_SIZE ) );
  address = tile.y * stride + tile.x * CRUDE_LIGHT_WORDS_COUNT;

  if ( ( scene.active_lights_count > 0 ) && min_light_id != CRUDE_LIGHTS_MAX_COUNT + 1 )
  {
    for ( uint light_id = min_light_id; light_id <= max_light_id; ++light_id )
    {
      uint word_id = light_id / 32;
      uint bit_id = light_id % 32;

      if ( ( lights_tiles[ address + word_id ] & ( 1 << bit_id ) ) != 0 )
      {
        uint global_light_index = lights_indices[ light_id ];
        radiance += crude_calculate_point_light_shadow_contribution( lights[ global_light_index ], vertex_position ) * crude_calculate_point_light_contribution( lights[ global_light_index ], albedo.rgb, roughness, metalness, normal, vertex_position, camera_position, f0 );
      }
    }
  }

#ifdef CRUDE_RAYTRACED_DDGI
  indirect_irradiance = CRUDE_TEXTURE_LOD( scene.indirect_light_texture_index, screen_texcoord, 0 ).rgb;
  indirect_diffuse = indirect_irradiance * albedo.rgb;
  const float ao = 1.0f;
  radiance.xyz += indirect_diffuse * ao;
#endif /* CRUDE_RAYTRACED_DDGI */

  radiance.xyz += albedo.xyz * scene.ambient_color * scene.ambient_intensity;

  return radiance;
}

#endif /* CRUDE_STAGE_FRAGMENT */
#endif /* LIGHT_PBR || TRANSPARENT_NO_CULL */
#endif /* CRUDE_LIGTH_CALCULATION_GLSLI */