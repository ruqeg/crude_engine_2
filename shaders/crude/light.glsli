
#ifndef CRUDE_LIGHT_GLSLI
#define CRUDE_LIGHT_GLSLI

#define CRUDE_LIGHT_BINS_COUNT                         ( 16 )
#define CRUDE_LIGHTS_MAX_COUNT                         ( 256 )
#define CRUDE_LIGHT_TILE_SIZE                          ( 8 )
#define CRUDE_LIGHT_WORDS_COUNT                        ( ( CRUDE_LIGHTS_MAX_COUNT + 31 ) / 32 )
#define CRUDE_MAX_MESHLETS_PER_LIGHT                   ( 45000 )

#define CRUDE_SHADOW_FILTER_NUM_SAMPLES 16
#define CRUDE_SHADOW_FILTER_RADIUS 1.5

const vec2 filter_kernel[ CRUDE_SHADOW_FILTER_NUM_SAMPLES ] =
{
  vec2(-0.94201624, -0.39906216),
  vec2(0.94558609, -0.76890725),
  vec2(-0.094184101, -0.92938870),
  vec2(0.34495938, 0.29387760),
  vec2(-0.91588581, 0.45771432),
  vec2(-0.81544232, -0.87912464),
  vec2(-0.38277543, 0.27676845),
  vec2(0.97484398, 0.75648379),
  vec2(0.44323325, -0.97511554),
  vec2(0.53742981, -0.47373420),
  vec2(-0.26496911, -0.41893023),
  vec2(0.79197514, 0.19090188),
  vec2(-0.24188840, 0.99706507),
  vec2(-0.81409955, 0.91437590),
  vec2(0.19984126, 0.78641367),
  vec2(0.14383161, -0.14100790)
};

const vec3 crude_tetrahedron_face_a = vec3( 0.0, -0.57735026, 0.81649661 );
const vec3 crude_tetrahedron_face_b = vec3( 0.0, -0.57735026, -0.81649661 );
const vec3 crude_tetrahedron_face_c = vec3( -0.81649661, 0.57735026, 0.0 );
const vec3 crude_tetrahedron_face_d = vec3( 0.81649661, 0.57735026, 0.0 );

struct crude_light
{
  vec3                                                     world_position;
  float                                                    radius;
  vec3                                                     color;
  float                                                    intensity;
};

vec3
crude_schlick_fresnel
(
  in vec3                                                  f0,
  in float                                                 ndotl
)
{
  return f0 + ( 1.f - f0 ) * pow( ( 1.f - max( ndotl, 0.0 ) ), 5.f );
}

float
crude_trowbridge_reitz_distribution
(
  in float                                                 ndotm,
  in float                                                 r2
)
{
  float x1 = max( PI * ( 1.f + ndotm * ndotm * ( r2 - 1.f ) ), 0.0001f );
  float x2 = sign( max( ndotm, 0.f ) ) * r2;
  return x2 / x1;
}

float 
crude_hammon_smith_g_approximation
(
  in float                                                 ndotl_abs,
  in float                                                 ndotv_abs,
  in float                                                 r
)
{
  return 0.5f / ( mix( 2 * ndotl_abs * ndotv_abs, ndotl_abs + ndotv_abs, r ) );
}

uint 
crude_get_tetrahedron_face_index
(
  in vec3                                                  dir
)
{
  mat4x3 face_matrix;
  face_matrix[ 0 ] = crude_tetrahedron_face_a;
  face_matrix[ 1 ] = crude_tetrahedron_face_b;
  face_matrix[ 2 ] = crude_tetrahedron_face_c;
  face_matrix[ 3 ] = crude_tetrahedron_face_d; 
  vec4 dot_products = dir * face_matrix;
  float maximum = max (max( dot_products.x, dot_products.y ), max( dot_products.z, dot_products.w ) );
  
  uint index;
  if ( maximum == dot_products.x )
  {
    index = 0;
  }
  else if ( maximum == dot_products.y )
  {
    index = 1;
  }
  else if ( maximum == dot_products.z )
  {
    index = 2;
  }
  else
  { 
    index = 3;
  }

  return index;
}


#endif /* CRUDE_LIGHT_GLSLI */