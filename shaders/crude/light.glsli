
#ifndef CRUDE_LIGHT_GLSLI
#define CRUDE_LIGHT_GLSLI

#define CRUDE_LIGHT_BINS_COUNT                         ( 16 )
#define CRUDE_LIGHTS_MAX_COUNT                         ( 256 )
#define CRUDE_LIGHT_TILE_SIZE                          ( 8 )
#define CRUDE_LIGHT_WORDS_COUNT                        ( ( CRUDE_LIGHTS_MAX_COUNT + 31 ) / 32 )
#define CRUDE_MAX_MESHLETS_PER_LIGHT                   ( 45000 )

struct crude_light
{
  vec3                                                     world_position;
  float                                                    radius;
  vec3                                                     color;
  float                                                    intensity;
};

layout(set=CRUDE_MATERIAL_SET, binding=20) readonly buffer ZBins
{
  uint                                                     bins[];
};

layout(set=CRUDE_MATERIAL_SET, binding=21) readonly buffer Lights
{
  crude_light                                              lights[];
};

layout(set=CRUDE_MATERIAL_SET, binding=22) readonly buffer Tiles
{
  uint                                                     lights_tiles[];
};

layout(set=CRUDE_MATERIAL_SET, binding=23) readonly buffer LightIndices
{
  uint                                                     lights_indices[];
};

layout(set=CRUDE_MATERIAL_SET, binding=24, row_major) readonly buffer ShadowViews
{
  mat4                                                      pointlight_world_to_clip[];
};

vec3 crude_calculate_point_light_contribution( crude_light light, vec3 albedo, vec3 normal, vec3 world_position, vec3 view_position )
{
  vec3 light_to_pos = light.world_position - world_position;
  float light_distance = length( light_to_pos );
  vec3 lightdir = light_to_pos / light_distance;

  float fadeout = pow( clamp( 1.f - pow( light_distance / light.radius, 2.f ), 0.f, 1.f ), 2.f );   
  float ldotn = clamp( dot( lightdir, normal ), 0.f, 1.f );
  return fadeout * ldotn * ( light.color * light.intensity.xxx * albedo );
}

vec4 crude_calculate_lighting( vec4 albedo, vec3 normal, vec3 world_position, uvec2 position )
{
  vec4 final_color = vec4( 0 );

  vec4 view_position = vec4( world_position, 1.0 ) * camera.world_to_view;

  float linear_d = ( view_position.z - camera.znear ) / ( camera.zfar - camera.znear );
  int bin_index = int( linear_d * CRUDE_LIGHT_BINS_COUNT );
  uint bin_value = bins[ bin_index ];

  uint min_light_id = bin_value & 0xFFFF;
  uint max_light_id = ( bin_value >> 16 ) & 0xFFFF;

  uvec2 tile = position / uint( CRUDE_LIGHT_TILE_SIZE );

  uint stride = uint( CRUDE_LIGHT_WORDS_COUNT ) * ( uint( resolution.x ) / uint( CRUDE_LIGHT_TILE_SIZE ) );
  uint address = tile.y * stride + tile.x * CRUDE_LIGHT_WORDS_COUNT;

  if ( min_light_id != CRUDE_LIGHTS_MAX_COUNT + 1 )
  {
    for ( uint light_id = min_light_id; light_id <= max_light_id; ++light_id )
    {
      uint word_id = light_id / 32;
      uint bit_id = light_id % 32;

      if ( ( lights_tiles[ address + word_id ] & ( 1 << bit_id ) ) != 0 )
      {
        uint global_light_index = lights_indices[ light_id ];
        final_color.rgb += crude_calculate_point_light_contribution( lights[ global_light_index ], albedo.rgb, normal, world_position, view_position.xyz );
      }
    }
  }

  return vec4( final_color.rgb, 1.f );
}

#endif /* CRUDE_LIGHT_GLSLI */