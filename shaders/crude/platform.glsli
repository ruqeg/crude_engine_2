
#ifndef CRUDE_PLATFORM_GLSL
#define CRUDE_PLATFORM_GLSL

#define CRUDE_GLOBAL_SET 0
#define CRUDE_MATERIAL_SET 1

#define CRUDE_BINDLESS_BINDING 10
#define CRUDE_BINDLESS_IMAGES 11

#define PI 3.1415926538
#define CRUDE_TEXTURE_INVALID 0xffffffff

#extension GL_EXT_debug_printf : require
#extension GL_EXT_nonuniform_qualifier : require

/* Read only */
layout(set=CRUDE_GLOBAL_SET, binding=CRUDE_BINDLESS_BINDING) uniform sampler2D global_textures[];
layout(set=CRUDE_GLOBAL_SET, binding=CRUDE_BINDLESS_BINDING) uniform sampler3D global_textures_3d[];

uint crude_vec4_to_rgba( vec4 color )
{
  return ( uint( color.r * 255.f ) | ( uint( color.g * 255.f ) << 8 ) | ( uint( color.b * 255.f ) << 16 ) | ( ( uint( color.a * 255.f ) << 24 ) ) );
}

vec4 crude_unpack_color_rgba( uint color )
{
  return vec4( ( color & 0xffu ) / 255.f, ( ( color >> 8u ) & 0xffu ) / 255.f, ( ( color >> 16u ) & 0xffu ) / 255.f, ( ( color >> 24u ) & 0xffu ) / 255.f );
}

vec4 crude_unpack_color_abgr( uint color )
{
  return vec4( ( ( color >> 24u ) & 0xffu ) / 255.f, ( ( color >> 16u ) & 0xffu ) / 255.f, ( ( color >> 8u ) & 0xffu ) / 255.f, ( color & 0xffu ) / 255.f );
}

vec2 crude_sign_not_zero( vec2 v )
{
  return vec2( ( v.x >= 0.0 ) ? 1.0 : -1.0, ( v.y >= 0.0 ) ? 1.0 : -1.0 );
}

vec2 crude_octahedral_encode( vec3 n )
{
  vec2 p = n.xy * ( 1.0f / ( abs( n.x ) + abs( n.y ) + abs( n.z ) ) );
  return ( n.z < 0.0f ) ? ( ( 1.0 - abs( p.yx ) ) * crude_sign_not_zero( p ) ) : p;
}

/* https://twitter.com/Stubbesaurus/status/937994790553227264?s=20&t=U36PKMj7v2BFeQwDX6gEGQ */
vec3 crude_octahedral_decode( vec2 f )
{
  vec3 n = vec3( f.x, f.y, 1.0 - abs( f.x ) - abs( f.y ) );
  float t = max( -n.z, 0.0 );
  n.x += n.x >= 0.0 ? -t : t;
  n.y += n.y >= 0.0 ? -t : t;
  return normalize( n );
}

#endif /* CRUDE_PLATFORM_GLSL */