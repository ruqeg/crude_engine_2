
#ifndef CRUDE_PLATFORM_GLSL
#define CRUDE_PLATFORM_GLSL

#define CRUDE_GLOBAL_SET 0
#define CRUDE_MATERIAL_SET 1

#define CRUDE_BINDLESS_BINDING 10
#define CRUDE_BINDLESS_IMAGES 11

#define PI 3.1415926538
#define CRUDE_TEXTURE_INVALID 0xffffffff

#extension GL_EXT_debug_printf : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_control_flow_attributes : require

/* Read only */
layout(set=CRUDE_GLOBAL_SET, binding=CRUDE_BINDLESS_BINDING) uniform sampler2D global_textures[];
layout(set=CRUDE_GLOBAL_SET, binding=CRUDE_BINDLESS_BINDING) uniform sampler3D global_textures_3d[];

uint crude_vec4_to_rgba( vec4 color )
{
  return ( uint( color.r * 255.f ) | ( uint( color.g * 255.f ) << 8 ) | ( uint( color.b * 255.f ) << 16 ) | ( ( uint( color.a * 255.f ) << 24 ) ) );
}

vec4 crude_unpack_color_rgba( uint color )
{
  return vec4( ( color & 0xffu ) / 255.f, ( ( color >> 8u ) & 0xffu ) / 255.f, ( ( color >> 16u ) & 0xffu ) / 255.f, ( ( color >> 24u ) & 0xffu ) / 255.f );
}

vec4 crude_unpack_color_abgr( uint color )
{
  return vec4( ( ( color >> 24u ) & 0xffu ) / 255.f, ( ( color >> 16u ) & 0xffu ) / 255.f, ( ( color >> 8u ) & 0xffu ) / 255.f, ( color & 0xffu ) / 255.f );
}

vec2 crude_sign_not_zero( vec2 v )
{
  return vec2( ( v.x >= 0.0 ) ? 1.0 : -1.0, ( v.y >= 0.0 ) ? 1.0 : -1.0 );
}

vec2 crude_octahedral_encode( vec3 n )
{
  vec2 p = n.xy * ( 1.0f / ( abs( n.x ) + abs( n.y ) + abs( n.z ) ) );
  return ( n.z < 0.0f ) ? ( ( 1.0 - abs( p.yx ) ) * crude_sign_not_zero( p ) ) : p;
}

/* https://twitter.com/Stubbesaurus/status/937994790553227264?s=20&t=U36PKMj7v2BFeQwDX6gEGQ */
vec3 crude_octahedral_decode( vec2 f )
{
  vec3 n = vec3( f.x, f.y, 1.0 - abs( f.x ) - abs( f.y ) );
  float t = max( -n.z, 0.0 );
  n.x += n.x >= 0.0 ? -t : t;
  n.y += n.y >= 0.0 ? -t : t;
  return normalize( n );
}

vec3 crude_ndc_from_uv_depth( vec2 uv, float depth )
{
  return vec3( uv.x * 2 - 1, ( 1 - uv.y ) * 2 - 1, depth );
}

vec3 crude_world_position_from_depth( vec2 uv, float depth, mat4 clip_to_world )
{
  vec4 h = vec4( crude_ndc_from_uv_depth( uv, depth ), 1.0 );
  vec4 d = h * clip_to_world;
  return d.xyz / d.w;
}

/* https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl */

/* sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT */
const mat3 crude_aces_input_mat  =
{
  { 0.59719f, 0.35458f, 0.04823f },
  { 0.07600f, 0.90834f, 0.01566f },
  { 0.02840f, 0.13383f, 0.83777f }
};

/* ODT_SAT => XYZ => D60_2_D65 => sRGB */
const mat3 crude_aces_output_mat =
{
  {  1.60475f, -0.53108f, -0.07367f },
  { -0.10208f,  1.10813f, -0.00605f },
  { -0.00327f, -0.07276f,  1.07602f }
};

vec3 crude_rrt_and_odt_fit( vec3 v )
{
  vec3 a = v * ( v + 0.0245786f ) - 0.000090537f;
  vec3 b = v * ( 0.983729f * v + 0.4329510f ) + 0.238081f;
  return a / b;
}

vec3 crude_aces_fitted( vec3 color )
{
  color = color * crude_aces_input_mat;
  color = crude_rrt_and_odt_fit( color );
  color = color * crude_aces_output_mat;
  color = clamp( color, 0.f, 1.f );
  return color;
}

float crude_rgb_to_luminance( vec3 rgb )
{
  return dot( rgb, vec3( 0.2125, 0.7154, 0.0721 ) );
}

#ifdef CRUDE_STAGE_COMPUTE
#endif /* CRUDE_STAGE_COMPUTE */

#endif /* CRUDE_PLATFORM_GLSL */