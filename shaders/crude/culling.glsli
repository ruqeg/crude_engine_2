
#ifndef CRUDE_CULLING_GLSL
#define CRUDE_CULLING_GLSL

bool crude_clustered_backface_culling( vec3 center, float radius, vec3 cone_axis, float cone_cutoff, vec3 camera_pos )
{
  return dot( center - camera_pos, cone_axis ) >= cone_cutoff * length( center - camera_pos ) + radius;
}

bool crude_sphere_intersect( vec3 center_a, float radius_a, vec3 center_b, float radius_b )
{
	vec3 v = center_b - center_a;
	float total_radius = radius_a + radius_b;
	return dot( v, v ) < total_radius;
}

/* 2D Polyhedral Bounds of a Clipped, Perspective-Projected 3D Sphere. Michael Mara, Morgan McGuire. 2013 */
bool crude_bounding_sphere_to_clipped_aabb( vec3 c, float r, float znear, float p00, float p11, out vec4 aabb )
{
  if ( c.z - r < znear )
  {
    return false;
  }

  vec2 cx = vec2( c.x, c.z );
  vec2 vx = vec2( sqrt( dot( cx, cx ) - r * r ), r );
  vec2 minx = mat2( vx.x, vx.y, -vx.y, vx.x ) * cx;
  vec2 maxx = mat2( vx.x, -vx.y, vx.y, vx.x ) * cx;

  vec2 cy = vec2( -c.y, c.z );
  vec2 vy = vec2( sqrt( dot( cy, cy ) - r * r ), r );
  vec2 miny = mat2( vy.x, vy.y, -vy.y, vy.x ) * cy;
  vec2 maxy = mat2( vy.x, -vy.y, vy.y, vy.x ) * cy;

  aabb = vec4( minx.x / minx.y * p00, miny.x / miny.y * p11, maxx.x / maxx.y * p00, maxy.x / maxy.y * p11 );

  return true;
}

vec4 crude_clip_to_uv_space( vec4 v )
{
  return v.xwzy * vec4( 0.5f, -0.5f, 0.5f, -0.5f ) + vec4( 0.5f );
}

/*
 * Occlusion Culling
 * TODO:
 *  Continue testing using using a finer mip level if result are ambiguous
 */
bool crude_occlusion_culling( uint mesh_instance_draw_index, vec3 view_bounding_center, float radius, float znear, float projection_00, float projection_11, uint depth_pyramid_texture_index, vec3 world_bounding_center, vec3 camera_world_position, mat4 culling_view_projection )
{
  vec4 aabb_clip;
  bool occlusion_visible = true;
  if ( crude_bounding_sphere_to_clipped_aabb( view_bounding_center, radius, znear, projection_00, projection_11, aabb_clip ) )
  {
    vec4 aabb = crude_clip_to_uv_space( aabb_clip );

    ivec2 depth_pyramid_size = textureSize( global_textures[ nonuniformEXT( depth_pyramid_texture_index ) ], 0 );
    float width = ( aabb.z - aabb.x ) * depth_pyramid_size.x;
    float height = ( aabb.w - aabb.y ) * depth_pyramid_size.y;

    float level = 7;

    vec2 uv = ( aabb.xy + aabb.zw ) * 0.5;
    uv.y = 1 - uv.y;

    float depth = textureLod( global_textures[ nonuniformEXT( depth_pyramid_texture_index ) ], uv, level ).r;
    depth = max( depth, textureLod( global_textures[ nonuniformEXT( depth_pyramid_texture_index ) ], vec2( aabb.x, 1.0f - aabb.y ), level ).r );
    depth = max( depth, textureLod( global_textures[ nonuniformEXT( depth_pyramid_texture_index ) ], vec2( aabb.z, 1.0f - aabb.w ), level ).r );
    depth = max( depth, textureLod( global_textures[ nonuniformEXT( depth_pyramid_texture_index ) ], vec2( aabb.x, 1.0f - aabb.w ), level ).r );
    depth = max( depth, textureLod( global_textures[ nonuniformEXT( depth_pyramid_texture_index ) ], vec2( aabb.z, 1.0f - aabb.y ), level ).r );

    vec3 dir = normalize( camera_world_position - world_bounding_center );
    vec4 sceen_space_center_last = vec4( world_bounding_center + dir * radius, 1.0 ) * culling_view_projection;
    vec3 dir_position = world_bounding_center + dir * radius;

    float depth_sphere = sceen_space_center_last.z / sceen_space_center_last.w;

    sceen_space_center_last.x = sceen_space_center_last.x / sceen_space_center_last.w;
    sceen_space_center_last.y = sceen_space_center_last.y / sceen_space_center_last.w;
    occlusion_visible = ( depth_sphere <= depth );

    //crude_debug_draw_2d_box( vec2( aabb_clip.x, -aabb_clip.y ), vec2( aabb_clip.z, -aabb_clip.w ), occlusion_visible ? vec4(0,1,0,1) : vec4(1,0,0,1) );
  }

  return occlusion_visible;
}

uint crude_get_cube_face_mask( vec3 cubemap_pos, vec3 aabb_min, vec3 aabb_max )
{
  vec3 plane_normals[] = { vec3( -1, 1, 0 ), vec3( 1, 1, 0 ), vec3( 1, 0, 1 ), vec3( 1, 0, -1 ), vec3( 0, 1, 1 ), vec3( 0, -1, 1 ) };
  vec3 abs_plane_normals[] = { vec3( 1, 1, 0 ), vec3( 1, 1, 0 ), vec3( 1, 0, 1 ), vec3( 1, 0, 1 ), vec3( 0, 1, 1 ), vec3( 0, 1, 1 ) };

  vec3 aabb_center = ( aabb_min + aabb_max ) * 0.5f;

  vec3 center = aabb_center - cubemap_pos;
  vec3 extents = ( aabb_max - aabb_min ) * 0.5f;

  bool rp[ 6 ];
  bool rn[ 6 ];

  for ( uint i = 0; i < 6; ++i )
  {
    float dist = dot( center, plane_normals[ i ] );
    float radius = dot( extents, abs_plane_normals[ i ] );

    rp[ i ] = dist > -radius;
    rn[ i ] = dist < radius;
  }

  uint fpx = ( rn[ 0 ] && rp[ 1 ] && rp[ 2 ] && rp[ 3 ] && aabb_max.x > cubemap_pos.x ) ? 1 : 0;
  uint fnx = ( rp[ 0 ] && rn[ 1 ] && rn[ 2 ] && rn[ 3 ] && aabb_min.x < cubemap_pos.x ) ? 1 : 0;
  uint fpy = ( rp[ 0 ] && rp[ 1 ] && rp[ 4 ] && rn[ 5 ] && aabb_max.y > cubemap_pos.y ) ? 1 : 0;
  uint fny = ( rn[ 0 ] && rn[ 1 ] && rn[ 4 ] && rp[ 5 ] && aabb_min.y < cubemap_pos.y ) ? 1 : 0;
  uint fpz = ( rp[ 2 ] && rn[ 3 ] && rp[ 4 ] && rp[ 5 ] && aabb_max.z > cubemap_pos.z ) ? 1 : 0;
  uint fnz = ( rn[ 2 ] && rp[ 3 ] && rn[ 4 ] && rn[ 5 ] && aabb_min.z < cubemap_pos.z ) ? 1 : 0;

  return fpx | ( fnx << 1 ) | ( fpy << 2 ) | ( fny << 3 ) | ( fpz << 4 ) | ( fnz << 5 );
}

#endif /* CRUDE_CULLING_GLSL */