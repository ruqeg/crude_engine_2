
#ifdef CRUDE_VALIDATOR_LINTING
#extension GL_GOOGLE_include_directive : enable
#define COMPUTE_SAMPLE_IRRADIANCE
//#define CRUDE_MISS

#include "crude/platform.glsli"
#include "crude/scene.glsli"
#include "crude/light.glsli"
#endif /* CRUDE_VALIDATOR_LINTING */

#define CRUDE_PROBE_STATUS_OFF 0
#define CRUDE_PROBE_STATUS_SLEEP 1
#define CRUDE_PROBE_STATUS_ACTIVE 4
#define CRUDE_PROBE_STATUS_UNINITIALIZED 6
#define EPSILON 0.0001f

#if defined( PROBE_RAYTRACER ) || defined( PROBE_UPDATE_IRRADIANCE ) || defined( PROBE_UPDATE_VISIBILITY ) || defined( COMPUTE_SAMPLE_IRRADIANCE )
CRUDE_RBUFFER( ProbeStatusSSBO, 11 )
{
  uint                                                     probe_status[];
};
#endif /* PROBE_RAYTRACER || PROBE_UPDATE_IRRADIANCE || PROBE_UPDATE_VISIBILITY */

#if defined( PROBE_RAYTRACER ) || defined( PROBE_UPDATE_IRRADIANCE ) || defined( PROBE_UPDATE_VISIBILITY ) || defined( CALCULATE_PROBE_STATUS )  || defined( COMPUTE_SAMPLE_IRRADIANCE )
CRUDE_RBUFFER( DDGIConstants, 10 )
{
  ivec3                                                    probe_counts;
  int                                                      probe_rays;
  vec3                                                     probe_spacing;
  uint                                                     radiance_output_index;
  mat4                                                     random_rotation;
  vec3                                                     probe_grid_position;
  int                                                      irradiance_texture_width;
  int                                                      irradiance_texture_height;
  int                                                      irradiance_side_length;
  float                                                    hysteresis;
  int                                                      visibility_texture_width;
  int                                                      visibility_texture_height;
  int                                                      visibility_side_length;
  float                                                    self_shadow_bias;
  uint                                                     indirect_output_index;
  uint                                                     normal_texture_index;
  vec3                                                     reciprocal_probe_spacing;
    uint        grid_irradiance_output_index;
    uint        grid_visibility_texture_index;
  uint                                                     depth_texture_index;
};

int k_read_table[6] = {5, 3, 1, -1, -3, -5};

int crude_get_probe_index_from_pixels( ivec2 pixels, int probe_with_border_side, int full_texture_width )
{
 int probes_per_side = full_texture_width / probe_with_border_side;
  return int(pixels.x / probe_with_border_side) + probes_per_side * int(pixels.y / probe_with_border_side);
}

float sign_not_zero(in float k) {
    return (k >= 0.0) ? 1.0 : -1.0;
}

vec2 sign_not_zero2(in vec2 v) {
    return vec2(sign_not_zero(v.x), sign_not_zero(v.y));
}

// Returns a unit vector. Argument o is an octahedral vector packed via oct_encode,
// on the [-1, +1] square
vec3 oct_decode(vec2 o) {
    vec3 v = vec3(o.x, o.y, 1.0 - abs(o.x) - abs(o.y));
    if (v.z < 0.0) {
        v.xy = (1.0 - abs(v.yx)) * sign_not_zero2(v.xy);
    }
    return normalize(v);
}
// Compute normalized oct coord, mapping top left of top left pixel to (-1,-1) and bottom right to (1,1)
vec2 normalized_oct_coord(ivec2 fragCoord, int probe_side_length) {

    int probe_with_border_side = probe_side_length + 2;
    vec2 octahedral_texel_coordinates = ivec2((fragCoord.x - 1) % probe_with_border_side, (fragCoord.y - 1) % probe_with_border_side);

    octahedral_texel_coordinates += vec2(0.5f);
    octahedral_texel_coordinates *= (2.0f / float(probe_side_length));
    octahedral_texel_coordinates -= vec2(1.0f);

    return octahedral_texel_coordinates;
}

vec3 crude_spherical_fibonacci( float i, float n )
{
  const float PHI = sqrt( 5.0f ) * 0.5 + 0.5;
#define madfrac( A, B ) ( ( A ) * ( B ) - floor( ( A ) * ( B ) ) )
  float phi       = 2.0 * PI * madfrac( i, PHI - 1 );
  float cos_theta = 1.0 - ( 2.0 * i + 1.0 ) * ( 1.0 / n );
  float sin_theta = sqrt( clamp( 1.0 - cos_theta * cos_theta, 0.0f, 1.0f ) );

  return vec3( cos( phi ) * sin_theta, sin( phi ) * sin_theta, cos_theta );
#undef madfrac
}

ivec3 crude_probe_index_to_grid_indices( int probe_index )
{
  const int probe_x = probe_index % probe_counts.x;
  const int probe_counts_xy = probe_counts.x * probe_counts.y;

  const int probe_y = ( probe_index % probe_counts_xy ) / probe_counts.x;
  const int probe_z = probe_index / probe_counts_xy;

  return ivec3( probe_x, probe_y, probe_z );
}

vec3 crude_grid_indices_to_world_no_offsets( ivec3 grid_indices )
{
  return grid_indices * probe_spacing + probe_grid_position;
}

vec3 crude_grid_indices_to_world( ivec3 grid_indices, int probe_index )
{
  const int probe_counts_xy = probe_counts.x * probe_counts.y;
  ivec2 probe_offset_sampling_coordinates = ivec2(probe_index % probe_counts_xy, probe_index / probe_counts_xy);
  vec3 probe_offset = vec3(0);

  return crude_grid_indices_to_world_no_offsets( grid_indices ) + probe_offset;
}

ivec3 world_to_grid_indices( vec3 world_position ) {
    return clamp(ivec3((world_position - probe_grid_position) * reciprocal_probe_spacing), ivec3(0), probe_counts - ivec3(1));
}

int probe_indices_to_index(in ivec3 probe_coords) {
    return int(probe_coords.x + probe_coords.y * probe_counts.x + probe_coords.z * probe_counts.x * probe_counts.y);
}


vec2 get_probe_uv(vec3 direction, int probe_index, int full_texture_width, int full_texture_height, int probe_side_length) {

    // Get octahedral coordinates (-1,1)
    const vec2 octahedral_coordinates = crude_octahedral_encode(normalize(direction));
    // TODO: use probe index for this.
    const float probe_with_border_side = float(probe_side_length) + 2.0f;
    const int probes_per_row = (full_texture_width) / int(probe_with_border_side);
    // Get probe indices in the atlas
    ivec2 probe_indices = ivec2((probe_index % probes_per_row), 
                               (probe_index / probes_per_row));
    
    // Get top left atlas texels
    vec2 atlas_texels = vec2( probe_indices.x * probe_with_border_side, probe_indices.y * probe_with_border_side );
    // Account for 1 pixel border
    atlas_texels += vec2(1.0f);
    // Move to center of the probe area
    atlas_texels += vec2(probe_side_length * 0.5f);
    // Use octahedral coordinates (-1,1) to move between internal pixels, no border
    atlas_texels += octahedral_coordinates * (probe_side_length * 0.5f);
    // Calculate final uvs
    const vec2 uv = atlas_texels / vec2(float(full_texture_width), float(full_texture_height));
    return uv;
}
vec3 sample_irradiance( vec3 world_position, vec3 normal, vec3 camera_position ) {

    const vec3 Wo = normalize(camera_position.xyz - world_position);
    // Bias vector to offset probe sampling based on normal and view vector.
    const float minimum_distance_between_probes = 1.0f;
    vec3 bias_vector = (normal * 0.2f + Wo * 0.8f) * (0.75f * minimum_distance_between_probes) * self_shadow_bias;

    vec3 biased_world_position = world_position + bias_vector;

    // Sample at world position + probe offset reduces shadow leaking.
    ivec3 base_grid_indices = world_to_grid_indices(biased_world_position);
    vec3 base_probe_world_position = crude_grid_indices_to_world_no_offsets( base_grid_indices );

    // alpha is how far from the floor(currentVertex) position. on [0, 1] for each axis.
    vec3 alpha = clamp((biased_world_position - base_probe_world_position) , vec3(0.0f), vec3(1.0f));

    vec3  sum_irradiance = vec3(0.0f);
    float sum_weight = 0.0f;

    // Iterate over adjacent probe cage
    for (int i = 0; i < 8; ++i) {
        // Compute the offset grid coord and clamp to the probe grid boundary
        // Offset = 0 or 1 along each axis
        ivec3  offset = ivec3(i, i >> 1, i >> 2) & ivec3(1);
        ivec3  probe_grid_coord = clamp(base_grid_indices + offset, ivec3(0), probe_counts - ivec3(1));
        int probe_index = probe_indices_to_index(probe_grid_coord);

        // Make cosine falloff in tangent plane with respect to the angle from the surface to the probe so that we never
        // test a probe that is *behind* the surface.
        // It doesn't have to be cosine, but that is efficient to compute and we must clip to the tangent plane.
        vec3 probe_pos = crude_grid_indices_to_world(probe_grid_coord, probe_index);

        // Compute the trilinear weights based on the grid cell vertex to smoothly
        // transition between probes. Avoid ever going entirely to zero because that
        // will cause problems at the border probes. This isn't really a lerp. 
        // We're using 1-a when offset = 0 and a when offset = 1.
        vec3 trilinear = mix(1.0 - alpha, alpha, offset);
        float weight = 1.0;

        if ( true ) {
            // Computed without the biasing applied to the "dir" variable. 
            // This test can cause reflection-map looking errors in the image
            // (stuff looks shiny) if the transition is poor.
            vec3 direction_to_probe = normalize(probe_pos - world_position);

            // The naive soft backface weight would ignore a probe when
            // it is behind the surface. That's good for walls. But for small details inside of a
            // room, the normals on the details might rule out all of the probes that have mutual
            // visibility to the point. So, we instead use a "wrap shading" test below inspired by
            // NPR work.

            // The small offset at the end reduces the "going to zero" impact
            // where this is really close to exactly opposite
            const float dir_dot_n = (dot(direction_to_probe, normal) + 1.0) * 0.5f;
            weight *= (dir_dot_n * dir_dot_n) + 0.2;
        }

        // Bias the position at which visibility is computed; this avoids performing a shadow 
        // test *at* a surface, which is a dangerous location because that is exactly the line
        // between shadowed and unshadowed. If the normal bias is too small, there will be
        // light and dark leaks. If it is too large, then samples can pass through thin occluders to
        // the other side (this can only happen if there are MULTIPLE occluders near each other, a wall surface
        // won't pass through itself.)
        vec3 probe_to_biased_point_direction = biased_world_position - probe_pos;
        float distance_to_biased_point = length(probe_to_biased_point_direction);
        probe_to_biased_point_direction *= 1.0 / distance_to_biased_point;

        // Visibility
        if ( true ) {

            vec2 uv = get_probe_uv(probe_to_biased_point_direction, probe_index, visibility_texture_width, visibility_texture_height, visibility_side_length );

            vec2 visibility = textureLod(global_textures[nonuniformEXT(grid_visibility_texture_index)], uv, 0).rg;

            float mean_distance_to_occluder = visibility.x;

            float chebyshev_weight = 1.0;
            if (distance_to_biased_point > mean_distance_to_occluder) {
                // In "shadow"
                float variance = abs((visibility.x * visibility.x) - visibility.y);
                // http://www.punkuser.net/vsm/vsm_paper.pdf; equation 5
                // Need the max in the denominator because biasing can cause a negative displacement
                const float distance_diff = distance_to_biased_point - mean_distance_to_occluder;
                chebyshev_weight = variance / (variance + (distance_diff * distance_diff));
                
                // Increase contrast in the weight
                chebyshev_weight = max((chebyshev_weight * chebyshev_weight * chebyshev_weight), 0.0f);
            }

            // Avoid visibility weights ever going all of the way to zero because when *no* probe has
            // visibility we need some fallback value.
            chebyshev_weight = max(0.05f, chebyshev_weight);
            weight *= chebyshev_weight;
        }

        // Avoid zero weight
        weight = max(0.000001, weight);

        // A small amount of light is visible due to logarithmic perception, so
        // crush tiny weights but keep the curve continuous
        const float crushThreshold = 0.2f;
        if (weight < crushThreshold) {
            weight *= (weight * weight) * (1.f / (crushThreshold * crushThreshold));
        }

        vec2 uv = get_probe_uv(normal, probe_index, irradiance_texture_width, irradiance_texture_height, irradiance_side_length );

        vec3 probe_irradiance = textureLod(global_textures[nonuniformEXT(grid_irradiance_output_index)], uv, 0).rgb;

            probe_irradiance = pow(probe_irradiance, vec3(0.5f * 5.0f));

        // Trilinear weights
        weight *= trilinear.x * trilinear.y * trilinear.z + 0.001f;

        sum_irradiance += weight * probe_irradiance;
        sum_weight += weight;
    }

    vec3 net_irradiance = sum_irradiance / sum_weight;

        net_irradiance = net_irradiance * net_irradiance;

    vec3 irradiance = 0.5f * PI * net_irradiance * 0.95f;

    return irradiance;
}
#endif /* PROBE_RAYTRACER || PROBE_UPDATE_IRRADIANCE || PROBE_UPDATE_VISIBILITY || CALCULATE_PROBE_STATUS */

#if defined( PROBE_RAYTRACER )
#extension GL_EXT_ray_tracing : enable

struct crude_ray_payload
{
  vec3                                                     radiance;
  float                                                    distance;
};

CRUDE_RBUFFER( MeshDraws, 1 )
{
  crude_mesh_draw                                          mesh_draws[];
};

CRUDE_RBUFFER( MeshInstancesDraws, 2 )
{
  crude_mesh_instance_draw                                 mesh_instance_draws[];
};

CRUDE_RBUFFER( Lights, 3 ) 
{
  crude_light                                              lights[];
};

layout(set=CRUDE_MATERIAL_SET, binding=4) uniform accelerationStructureEXT acceleration_structure;

#if defined( CRUDE_CLOSEST_HIT )
layout(location=0) rayPayloadInEXT crude_ray_payload payload;

hitAttributeEXT vec2 barycentric_weights;

void main()
{
  vec3 radiance = vec3( 0 );
  float distance = 0.0f;
  if ( gl_HitKindEXT == gl_HitKindBackFacingTriangleEXT )
  {
    distance = gl_RayTminEXT + gl_HitTEXT;
    distance *= -0.2;      
    payload.radiance = radiance;
    payload.distance = distance;
    return;  
  }
  
  uint mesh_index = mesh_instance_draws[ gl_GeometryIndexEXT ].mesh_draw_index;
  crude_mesh_draw mesh = mesh_draws[ mesh_index ];

  int_array_type index_buffer = int_array_type( mesh.index_buffer );
  int i0 = index_buffer[ gl_PrimitiveID * 3 ].v;
  int i1 = index_buffer[ gl_PrimitiveID * 3 + 1 ].v;
  int i2 = index_buffer[ gl_PrimitiveID * 3 + 2 ].v;

  float_array_type vertex_buffer = float_array_type( mesh.position_buffer );
  vec4 p0 = vec4( vertex_buffer[ i0 * 3 + 0 ].v, vertex_buffer[ i0 * 3 + 1 ].v, vertex_buffer[ i0 * 3 + 2 ].v, 1.0 );
  vec4 p1 = vec4( vertex_buffer[ i1 * 3 + 0 ].v, vertex_buffer[ i1 * 3 + 1 ].v, vertex_buffer[ i1 * 3 + 2 ].v, 1.0 );
  vec4 p2 = vec4( vertex_buffer[ i2 * 3 + 0 ].v, vertex_buffer[ i2 * 3 + 1 ].v, vertex_buffer[ i2 * 3 + 2 ].v, 1.0 );

  mat4 model_to_world = mesh_instance_draws[ gl_GeometryIndexEXT ].model_to_world;
  vec4 p0_world = p0 * model_to_world;
  vec4 p1_world = p1 * model_to_world;
  vec4 p2_world = p2 * model_to_world;

  vec2_array_type texcoord_buffer = vec2_array_type( mesh.texcoord_buffer );
  vec2 uv0 = texcoord_buffer[ i0 ].v;
  vec2 uv1 = texcoord_buffer[ i1 ].v;
  vec2 uv2 = texcoord_buffer[ i2 ].v;

  float b = barycentric_weights.x;
  float c = barycentric_weights.y;
  float a = 1 - b - c;

  vec2 uv = ( a * uv0 + b * uv1 + c * uv2 );
  vec3 albedo = textureLod( global_textures[ nonuniformEXT( mesh.textures.x ) ], uv, 3 ).rgb;

  float_array_type normals_buffer = float_array_type( mesh.normal_buffer );
  vec3 n0 = vec3( normals_buffer[ i0 * 3 + 0 ].v, normals_buffer[ i0 * 3 + 1 ].v, normals_buffer[ i0 * 3 + 2 ].v );
  vec3 n1 = vec3( normals_buffer[ i1 * 3 + 0 ].v, normals_buffer[ i1 * 3 + 1 ].v, normals_buffer[ i1 * 3 + 2 ].v );
  vec3 n2 = vec3( normals_buffer[ i2 * 3 + 0 ].v, normals_buffer[ i2 * 3 + 1 ].v, normals_buffer[ i2 * 3 + 2 ].v );
  vec3 normal = a * n0 + b * n1 + c * n2;

  mat3 world_to_model = mat3( mesh_instance_draws[ gl_GeometryIndexEXT ].world_to_model );
  normal = normal * world_to_model;

  vec3 world_position = a * p0_world.xyz + b * p1_world.xyz + c * p2_world.xyz;

  // TODO
  crude_light light = lights[ 0 ];

  vec3 position_to_light = light.world_position - world_position;
  vec3 l = normalize( position_to_light );
  float NoL = clamp(dot(normal, l), 0.0, 1.0);

  vec3 light_to_position = light.world_position - world_position;
  float light_distance = length( light_to_position );

  float attenuation = max( 1.f - pow( light_distance / light.radius, 2.f ), 0.f );
  attenuation = attenuation * attenuation;
  vec3 light_intensity = vec3(0.0f);
  if ( attenuation > 0.001f && NoL > 0.001f )
  {
    light_intensity += ( light.intensity * attenuation * NoL ) * light.color;
  }

  vec3 diffuse = albedo * light_intensity;
  radiance = diffuse;
  distance = gl_RayTminEXT + gl_HitTEXT;

  payload.radiance = radiance;
  payload.distance = distance;
}
#endif /* CRUDE_CLOSEST_HIT */


#if defined( CRUDE_RAYGEN )
layout(location=0) rayPayloadEXT crude_ray_payload payload;

void main()
{
  const ivec2 pixel_coord = ivec2( gl_LaunchIDEXT.xy );
  const int probe_index = pixel_coord.y;
  const int ray_index = pixel_coord.x;

  const bool skip_probe = ( probe_status[ probe_index ] == CRUDE_PROBE_STATUS_OFF ) || ( probe_status[ probe_index ] == CRUDE_PROBE_STATUS_UNINITIALIZED );
  if ( skip_probe )
  {
    return;
  }

  ivec3 probe_grid_indices = crude_probe_index_to_grid_indices( probe_index );
  vec3 ray_origin = crude_grid_indices_to_world( probe_grid_indices, probe_index );
  vec3 direction = normalize( mat3( random_rotation ) * crude_spherical_fibonacci( ray_index, probe_rays ) );
  payload.radiance = vec3(0);
  payload.distance = 0;

  traceRayEXT( acceleration_structure, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, ray_origin, 0.0, direction, 100.0, 0 );

  imageStore( global_images_2d[ radiance_output_index ], ivec2( ray_index, probe_index ), vec4( payload.radiance, payload.distance ) );
}
#endif /* CRUDE_RAYGEN */

 
#if defined( CRUDE_MISS )
layout(location=0) rayPayloadInEXT crude_ray_payload payload;

void main()
{
  payload.radiance = vec3( 0.529, 0.807, 0.921 );
  payload.distance = 1000;
}
#endif /* CRUDE_MISS */
#endif /* PROBE_RAYTRACER */

#if defined( PROBE_UPDATE_IRRADIANCE )
layout(set=CRUDE_MATERIAL_SET, binding=41, rgba16f) uniform image2D irradiance_image;

void main()
{
  ivec3 coords = ivec3( gl_GlobalInvocationID.xyz );

  int probe_texture_width = irradiance_texture_width;
  int probe_texture_height = irradiance_texture_height;
  int probe_side_length = irradiance_side_length;
  
  if ( coords.x >= probe_texture_width || coords.y >= probe_texture_height )
  {
    return;
  }

  uint probe_with_border_side = probe_side_length + 2;
  uint probe_last_pixel = probe_side_length + 1;

  int probe_index = crude_get_probe_index_from_pixels(coords.xy, int(probe_with_border_side), probe_texture_width);

  bool border_pixel = ( ( gl_GlobalInvocationID.x % probe_with_border_side ) == 0 ) || ( ( gl_GlobalInvocationID.x % probe_with_border_side ) == probe_last_pixel );
  border_pixel = border_pixel || ( ( gl_GlobalInvocationID.y % probe_with_border_side ) == 0 ) || ( ( gl_GlobalInvocationID.y % probe_with_border_side ) == probe_last_pixel );

  if ( !border_pixel )
  {
    vec4 result = vec4( 0 );
    float energy_conservation = 0.95;

    uint backfaces = 0;
    uint max_backfaces = uint( probe_rays * 0.1f );

    for ( int ray_index = 0; ray_index < probe_rays; ++ray_index )
    {
      ivec2 sample_position = ivec2( ray_index, probe_index );
      vec3 ray_direction = normalize( crude_spherical_fibonacci( ray_index, probe_rays ) * mat3( random_rotation ) );
      vec3 texel_direction = oct_decode( normalized_oct_coord( coords.xy, probe_side_length ) );
      float weight = max(0.0, dot(texel_direction, ray_direction));
      float distance2 = texelFetch(global_textures[nonuniformEXT(radiance_output_index)], sample_position, 0).w;
      if ( distance2 < 0.0f )
      {
        ++backfaces;

        if (backfaces >= max_backfaces)
          return;

        continue;
      }

      if (weight >= EPSILON)
      {
        vec3 radiance = texelFetch(global_textures[nonuniformEXT(radiance_output_index)], sample_position, 0).rgb;
        radiance.rgb *= energy_conservation;
        result += vec4(radiance * weight, weight);
      }
    }

    if (result.w > EPSILON)
    {
      result.xyz /= result.w;
      result.w = 1.0f;
    }

    vec4 previous_value = imageLoad( irradiance_image, coords.xy );

    //if ( use_perceptual_encoding() ) {
      result.rgb = pow(result.rgb, vec3(1.0f / 5.0f));    
    //}

    result = mix( result, previous_value, hysteresis );
    imageStore(irradiance_image, coords.xy, result);

        // NOTE: returning here.
        return;
    }

    // Wait for all local threads to have finished to copy the border pixels.
    groupMemoryBarrier();
    barrier();

    // Copy border pixel calculating source pixels.
    const uint probe_pixel_x = gl_GlobalInvocationID.x % probe_with_border_side;
    const uint probe_pixel_y = gl_GlobalInvocationID.y % probe_with_border_side;
    bool corner_pixel = (probe_pixel_x == 0 || probe_pixel_x == probe_last_pixel) &&
                        (probe_pixel_y == 0 || probe_pixel_y == probe_last_pixel);
    bool row_pixel = (probe_pixel_x > 0 && probe_pixel_x < probe_last_pixel);

    ivec2 source_pixel_coordinate = coords.xy;

    if ( corner_pixel ) {
        source_pixel_coordinate.x += probe_pixel_x == 0 ? probe_side_length : -probe_side_length;
        source_pixel_coordinate.y += probe_pixel_y == 0 ? probe_side_length : -probe_side_length;

        //if (show_border_type()) {
        //    source_pixel_coordinate = ivec2(2,2);
        //}
    }
    else if ( row_pixel ) {
        source_pixel_coordinate.x += k_read_table[probe_pixel_x - 1];
        source_pixel_coordinate.y += (probe_pixel_y > 0) ? -1 : 1;

        //if (show_border_type()) {
        //    source_pixel_coordinate = ivec2(3,3);
        //}
    }
    else {
        source_pixel_coordinate.x += (probe_pixel_x > 0) ? -1 : 1;
        source_pixel_coordinate.y += k_read_table[probe_pixel_y - 1];

        //if (show_border_type()) {
        //    source_pixel_coordinate = ivec2(4,4);
        //}
    }

    vec4 copied_data = imageLoad( irradiance_image, source_pixel_coordinate );

    // Debug border source coordinates
    //if ( show_border_source_coordinates() ) {
    //    copied_data = vec4(coords.xy, source_pixel_coordinate);
    //}

    // Debug border with color red
    //if (show_border_vs_inside()) {
    //    copied_data = vec4(1,0,0,1);
    //}

    imageStore( irradiance_image, coords.xy, copied_data );
}
#endif /* PROBE_UPDATE_IRRADIANCE */

#if defined( PROBE_UPDATE_VISIBILITY )
layout(set=CRUDE_MATERIAL_SET, binding=41, rgba16f) uniform image2D visibility_image;

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

void main() {

    ivec3 coords = ivec3(gl_GlobalInvocationID.xyz);

    int probe_texture_width = visibility_texture_width;
    int probe_texture_height = visibility_texture_height;
    int probe_side_length = visibility_side_length;

    // Early out for 1 pixel border around all image and outside bound pixels.
    if (coords.x >= probe_texture_width || coords.y >= probe_texture_height) {
        return;
    }

    const uint probe_with_border_side = probe_side_length + 2;
    const uint probe_last_pixel = probe_side_length + 1;

    int probe_index = crude_get_probe_index_from_pixels(coords.xy, int(probe_with_border_side), probe_texture_width);

    // Check if thread is a border pixel
    bool border_pixel = ((gl_GlobalInvocationID.x % probe_with_border_side) == 0) || ((gl_GlobalInvocationID.x % probe_with_border_side ) == probe_last_pixel );
    border_pixel = border_pixel || ((gl_GlobalInvocationID.y % probe_with_border_side) == 0) || ((gl_GlobalInvocationID.y % probe_with_border_side ) == probe_last_pixel );

    // Perform full calculations
    if ( !border_pixel ) {
        vec4 result = vec4(0);

        const float energy_conservation = 0.95;

        uint backfaces = 0;
        uint max_backfaces = uint(probe_rays * 0.1f);

        for ( int ray_index = 0; ray_index < probe_rays; ++ray_index ) {
            ivec2 sample_position = ivec2( ray_index, probe_index );

            vec3 ray_direction = normalize( mat3(random_rotation) * crude_spherical_fibonacci(ray_index, probe_rays) );

            vec3 texel_direction = oct_decode(normalized_oct_coord(coords.xy, probe_side_length));

            float weight = max(0.0, dot(texel_direction, ray_direction));

            float distance2 = texelFetch(global_textures[nonuniformEXT(radiance_output_index)], sample_position, 0).w;
            if ( distance2 < 0.0f ) {
                ++backfaces;

                // Early out: only blend ray radiance into the probe if the backface threshold hasn't been exceeded
                if (backfaces >= max_backfaces)
                    return;

                continue;
            }

            // TODO: spacing is 1.0f
            float probe_max_ray_distance = 1.0f * 1.5f;

            // Increase or decrease the filtered distance value's "sharpness"
            weight = pow(weight, 2.5f);

            if (weight >= EPSILON) {
                float distance = texelFetch(global_textures[nonuniformEXT(radiance_output_index)], sample_position, 0).w;
                // Limit
                distance = min(abs(distance), probe_max_ray_distance);
                vec3 value = vec3(distance, distance * distance, 0);
                // Storing the sum of the weights in alpha temporarily
                result += vec4(value * weight, weight);
            }
        }

        if (result.w > EPSILON) {
            result.xyz /= result.w;
            result.w = 1.0f;
        }

        // Read previous frame value
        vec2 previous_value = imageLoad( visibility_image, coords.xy ).rg;

        result.rg = mix( result.rg, previous_value, hysteresis );
        imageStore(visibility_image, coords.xy, vec4(result.rg, 0, 1));

        // NOTE: returning here.
        return;
    }

    // Wait for all local threads to have finished to copy the border pixels.
    groupMemoryBarrier();
    barrier();

    // Copy border pixel calculating source pixels.
    const uint probe_pixel_x = gl_GlobalInvocationID.x % probe_with_border_side;
    const uint probe_pixel_y = gl_GlobalInvocationID.y % probe_with_border_side;
    bool corner_pixel = (probe_pixel_x == 0 || probe_pixel_x == probe_last_pixel) &&
                        (probe_pixel_y == 0 || probe_pixel_y == probe_last_pixel);
    bool row_pixel = (probe_pixel_x > 0 && probe_pixel_x < probe_last_pixel);

    ivec2 source_pixel_coordinate = coords.xy;

    if ( corner_pixel ) {
        source_pixel_coordinate.x += probe_pixel_x == 0 ? probe_side_length : -probe_side_length;
        source_pixel_coordinate.y += probe_pixel_y == 0 ? probe_side_length : -probe_side_length;
    }
    else if ( row_pixel ) {
        source_pixel_coordinate.x += k_read_table[probe_pixel_x - 1];
        source_pixel_coordinate.y += (probe_pixel_y > 0) ? -1 : 1;
    }
    else {
        source_pixel_coordinate.x += (probe_pixel_x > 0) ? -1 : 1;
        source_pixel_coordinate.y += k_read_table[probe_pixel_y - 1];
    }

    vec4 copied_data = imageLoad( visibility_image, source_pixel_coordinate );


    imageStore( visibility_image, coords.xy, copied_data );
}
#endif /* PROBE_UPDATE_VISIBILITY */

#if defined( CALCULATE_PROBE_STATUS )

CRUDE_RWBUFFER( ProbeStatusSSBO, 11 )
{
  uint                                                     probe_status[];
};

layout( push_constant ) uniform PushConstants
{
  uint                                                     first_frame;
};

void main()
{
  ivec3 coords = ivec3( gl_GlobalInvocationID.xyz );
  int offset = 0;

  int probe_index = coords.x;

  int closest_backface_index = -1;
  float closest_backface_distance = 100000000.f;

  int closest_frontface_index = -1;
  float closest_frontface_distance = 100000000.f;

  int farthest_frontface_index = -1;
  float farthest_frontface_distance = 0;

  int backfaces_count = 0;
  uint flag = first_frame == 1 ? CRUDE_PROBE_STATUS_UNINITIALIZED : probe_status[probe_index];

    // Worst case, view and normal contribute in the same direction, so need 2x self-shadow bias.
  vec3 outerBounds = normalize(probe_spacing) * (length(probe_spacing) + (2.0f * self_shadow_bias));

    for (int ray_index = 0; ray_index < probe_rays; ++ray_index) {

        ivec2 ray_tex_coord = ivec2(ray_index, probe_index);

        // Distance is negative if we hit a backface
        float d_front = texelFetch(global_textures[nonuniformEXT(radiance_output_index)], ray_tex_coord, 0).w;
        float d_back = -d_front;

        //Backface test backface -> position.w < 0.0f
        if (d_back > 0.0f) {
            backfaces_count += 1;
            if (d_back < closest_backface_distance) {
                // This distance is negative on a backface hit
                closest_backface_distance = d_back;
                // Recompute ray direction
                closest_backface_index = ray_index;
            }
        }

        if (d_front > 0.0f) {
            // Need to check all frontfaces to see if any are wihtin shading range.
            vec3 frontFaceDirection = d_front * normalize( mat3(random_rotation) * crude_spherical_fibonacci(ray_index, probe_rays) );
            if (all(lessThan(abs(frontFaceDirection), outerBounds))) {
                // There is a static surface being shaded by this probe. Make it "just vigilant".
                flag = CRUDE_PROBE_STATUS_ACTIVE;
            }
            if (d_front < closest_frontface_distance) {
                closest_frontface_distance = d_front;
                closest_frontface_index = ray_index;
            } else if (d_front > farthest_frontface_distance) {
                farthest_frontface_distance = d_front;
                farthest_frontface_index = ray_index;
            }
        }
    }

    // If there's a close backface AND you see more than 25% backfaces, assume you're inside something.
    if (closest_backface_index != -1 && (float(backfaces_count) / probe_rays) > 0.25f) {
        // At this point, we were just in a wall, so set probe to "Off".
        flag = CRUDE_PROBE_STATUS_OFF;
    }
    else if (closest_frontface_index == -1) {
        // Probe sees only backfaces and sky, so set probe to "Off".
       flag = CRUDE_PROBE_STATUS_OFF;
    }
    else if (closest_frontface_distance < 0.05f) {
        // We hit no backfaces and a close frontface (within 2 cm). Set to "Newly Vigilant".
        flag = CRUDE_PROBE_STATUS_ACTIVE;
    } 

    // Write probe status
    probe_status[probe_index] = flag;
}

#endif /* CALCULATE_PROBE_STATUS */


#if defined( COMPUTE_SAMPLE_IRRADIANCE )

CRUDE_UNIFORM( SceneConstant, 0 ) 
{
  crude_scene                                              scene;
};

CRUDE_PUSH_CONSTANT( PushConstants )
{
  uint                                                     output_resolution_half;
};

vec2 uv_nearest( vec2 pixel, vec2 texture_size )
{
  vec2 uv = floor(pixel) + 0.5f;
  return uv / texture_size;
}


ivec2 pixel_offsets[] = ivec2[]( ivec2(0,0), ivec2(0,1), ivec2(1,0), ivec2(1,1));

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main()
{
    ivec3 coords = ivec3(gl_GlobalInvocationID.xyz);

    int resolution_divider = output_resolution_half == 1 ? 2 : 1;
    vec2 screen_uv = uv_nearest(coords.xy, scene.resolution / resolution_divider);
    
    float raw_depth = 1.0f;
    int chosen_hiresolution_sample_index = 0;
    if (output_resolution_half == 1) {
        float closer_depth = 0.f;
        for ( int i = 0; i < 4; ++i ) {

            float depth = texelFetch(global_textures[nonuniformEXT(scene.depth_texture_index)], (coords.xy) * 2 + pixel_offsets[i], 0).r;

            if ( closer_depth < depth ) {
                closer_depth = depth;
                chosen_hiresolution_sample_index = i;
            }
        }

        raw_depth = closer_depth;
    }
    else {
        raw_depth = texelFetch(global_textures[nonuniformEXT(scene.depth_texture_index)], coords.xy, 0).r;
    }

    if ( raw_depth == 1.0f ) {
        imageStore(global_images_2d[ indirect_output_index ], coords.xy, vec4(0,0,0,1));
        return;
    }

    // Manually fetch normals when in low resolution.
    vec3 normal = vec3(0);

    if (output_resolution_half == 1) {
        vec2 encoded_normal = texelFetch(global_textures[nonuniformEXT(normal_texture_index)], (coords.xy) * 2 + pixel_offsets[chosen_hiresolution_sample_index], 0).rg;
        normal = normalize(crude_octahedral_decode(encoded_normal));
    }
    else {
        vec2 encoded_normal = texelFetch(global_textures[nonuniformEXT(normal_texture_index)], coords.xy, 0).rg;
        normal = crude_octahedral_decode(encoded_normal);
    }

    const vec3 pixel_world_position = crude_world_position_from_depth(screen_uv, raw_depth, scene.camera.clip_to_world );
    
    vec3 irradiance = sample_irradiance( pixel_world_position, normal, scene.camera.position );

    imageStore(global_images_2d[ indirect_output_index ], coords.xy, vec4(irradiance,1));
}

#endif /* COMPUTE_SAMPLE_IRRADIANCE */