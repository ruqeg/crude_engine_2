

#ifdef CRUDE_VALIDATOR_LINTING
#extension GL_GOOGLE_include_directive : enable
#include "crude/platform.glsli"
#include "crude/scene.glsli"
#endif /* CRUDE_VALIDATOR_LINTING */

#extension GL_EXT_ray_tracing : enable

layout(location=0) rayPayloadEXT vec4 payload;

layout(binding=10, set=CRUDE_MATERIAL_SET) uniform accelerationStructureEXT as;
layout(binding=11, set=CRUDE_MATERIAL_SET, row_major, std140) buffer rayParams
{
  uint                                                     sbt_offset;
  uint                                                     sbt_stride;
  uint                                                     miss_index;
  uint                                                     out_image_index;
};

vec3 compute_ray_dir( uvec3 launchID, uvec3 launchSize )
{
  float x = ( 2 * ( float( launchID.x ) + 0.5 ) / float( launchSize.x ) - 1.0 );
  float y = ( 1.0 - 2 * ( float( launchID.y ) + 0.5 ) / float( launchSize.y ) );
  vec4 dir = vec4( x, y, 1, 1 ) * camera.clip_to_world;
  dir = normalize( dir );
  return dir.xyz;
}

void main()
{
  payload = vec4( 0, 0, 1, 1 );

  traceRayEXT(
    as, /* topLevel */
    gl_RayFlagsOpaqueEXT, /* rayFlags */
    0xff, /* cullMask */
    sbt_offset, /* sbtRecordOffset */
    sbt_stride, /* sbtRecordStride */
    miss_index, /* missIndex */
    camera.position, /* origin */
    0.0, /* tmin */
    compute_ray_dir( gl_LaunchIDEXT, gl_LaunchSizeEXT ), /* direction */
    100.0, /* Tmax */
    0 /* payload index */
  );

  imageStore( global_images_2d[ out_image_index ], ivec2( gl_LaunchIDEXT.xy ), payload );
}