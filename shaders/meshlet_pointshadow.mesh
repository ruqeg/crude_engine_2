
#extension GL_EXT_mesh_shader : require

#ifdef CRUDE_VALIDATOR_LINTING
#include "crude/platform.glsli"
#include "crude/debug.glsli"
#include "crude/scene.glsli"
#include "crude/meshlet.glsli"
#include "crude/mesh.glsli"
#include "crude/culling.glsli"
#include "crude/light.glsli"
#endif /* CRUDE_VALIDATOR_LINTING */

layout(local_size_x=128, local_size_y=1, local_size_z=1) in;
layout(triangles) out;
layout(max_vertices=128, max_primitives=124) out;

layout(location=0) out vec2 out_texcoord[];
layout(location=1) out flat uint out_mesh_draw_index[];
layout(location=2) out vec3 out_normals[];

layout(set=CRUDE_MATERIAL_SET, binding=10) readonly buffer ShadowCameraSpheres
{
  vec4                                                     pointlight_spheres[];
};

layout(set=CRUDE_MATERIAL_SET, binding=12) readonly buffer MeshletDrawCommands
{
  uvec4                                                    pointshadow_meshlet_draw_commands[];
};

layout(set=CRUDE_MATERIAL_SET, binding=13) readonly buffer MeshletInstances
{
  uvec2                                                    meshletes_instances[];
};

layout(set=CRUDE_MATERIAL_SET, binding=14) buffer PointLightMeshletCount
{
  uint                                                     pointshadow_meshletes_instances_count[];
};

taskPayloadSharedEXT struct
{
  uint                                                     meshlet_indices[ 128 ];
  uint                                                     mesh_instance_draw_indices[ 128 ];
  uint                                                     light_index_face_index;
} shared_data;

/* GPU Pro 6 Tile-Based Omnidirectional Shadows Hawar Doghramachi, http://www.hd-prg.com/tileBasedShadows.html */
const vec3 plane_normals[ 12 ] =
{
  vec3(0.00000000, -0.03477280, 0.99939519),
  vec3(-0.47510946, -0.70667917, 0.52428567),
  vec3(0.47510946, -0.70667917, 0.52428567),
  vec3(0.00000000, -0.03477280, -0.99939519),
  vec3(0.47510946, -0.70667917, -0.52428567),
  vec3(-0.47510946, -0.70667917, -0.52428567),
  vec3(-0.52428567, 0.70667917, -0.47510946),
  vec3(-0.52428567, 0.70667917, 0.47510946),
  vec3(-0.99939519, 0.03477280, 0.00000000),
  vec3(0.52428567, 0.70667917, -0.47510946),
  vec3(0.99939519, 0.03477280, 0.00000000),
  vec3(0.52428567, 0.70667917, 0.47510946)
};

float get_clip_distance( vec3 light_position, vec3 vertex_position, uint plane_index )
{
  vec3 normal = plane_normals[ plane_index ];
  return dot( vertex_position, normal ) + dot( light_position, -normal );
}

void main()
{
  uint task_index = gl_LocalInvocationID.x;
  uint local_meshlet_index = gl_WorkGroupID.x;
  uint global_meshlet_index = shared_data.meshlet_indices[ local_meshlet_index ];
  uint mesh_instance_draw_index = shared_data.mesh_instance_draw_indices[ local_meshlet_index ];
  uint mesh_draw_index = mesh_instance_draws[ mesh_instance_draw_index ].mesh_draw_index;
  
  uint mesh_index = meshlets[ global_meshlet_index ].mesh_index;
  uint vertices_count = uint( meshlets[ global_meshlet_index ].vertices_count );
  uint triangles_count = uint( meshlets[ global_meshlet_index ].triangles_count );
  
  uint vertices_offset = meshlets[ global_meshlet_index ].vertices_offset;
  uint triangles_offset = meshlets[ global_meshlet_index ].triangles_offset;

  uint light_index = shared_data.light_index_face_index >> 16;
  uint face_index = ( shared_data.light_index_face_index & 0xf );
  int layer_index = int( 4 * light_index + face_index );

  mat4 model_to_world = mesh_instance_draws[ mesh_instance_draw_index ].model_to_world;

  SetMeshOutputsEXT( vertices_count, triangles_count );
  
  for ( uint i = task_index; i < vertices_count; i += gl_WorkGroupSize.x )
  {
    uint vertex_index = vertices_indices[ i + vertices_offset ];
    vec4 model_position = vec4( vertices[ vertex_index ].position, 1.0 );
    
    vec4 world_position = model_position * model_to_world;
    gl_MeshVerticesEXT[ i ].gl_Position = world_position * pointlight_world_to_clip[ layer_index ];
    
    float clip_distances[ 3 ];
    vec3 light_position = pointlight_spheres[ light_index ].xyz;
    for( uint side_index = 0; side_index < 3; side_index++ )
    {
      clip_distances[ side_index ] = get_clip_distance( light_position, world_position.xyz, 3 * face_index + side_index );
    }
    gl_MeshVerticesEXT[ i ].gl_ClipDistance[ 0 ] = clip_distances[ 0 ]; 
    gl_MeshVerticesEXT[ i ].gl_ClipDistance[ 1 ] = clip_distances[ 1 ];
    gl_MeshVerticesEXT[ i ].gl_ClipDistance[ 2 ] = clip_distances[ 2 ];
  }

  for ( uint i = task_index; i < triangles_count; i += gl_WorkGroupSize.x )
  {
    uint triangle_index = uint( 3 * i + triangles_offset );
    gl_PrimitiveTriangleIndicesEXT[ i ] = uvec3( triangles_indices[ triangle_index ], triangles_indices[ triangle_index + 1 ], triangles_indices[ triangle_index + 2 ] );
  }
}