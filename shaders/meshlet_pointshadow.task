
#extension GL_EXT_mesh_shader : require
#extension GL_ARB_shader_draw_parameters : require
#extension GL_KHR_shader_subgroup_ballot: require

#ifdef CRUDE_VALIDATOR_LINTING
#extension GL_GOOGLE_include_directive : enable
#include "crude/platform.glsli"
#include "crude/debug.glsli"
#include "crude/scene.glsli"
#include "crude/meshlet.glsli"
#include "crude/mesh.glsli"
#include "crude/culling.glsli"
#include "crude/light.glsli"
#endif /* CRUDE_VALIDATOR_LINTING */

layout(local_size_x=32) in;

layout(set=CRUDE_MATERIAL_SET, binding=10) readonly buffer ShadowCameraSpheres
{
  vec4                                                     pointlight_spheres[];
};

layout(set=CRUDE_MATERIAL_SET, binding=12) readonly buffer MeshletDrawCommands
{
  uvec4                                                    pointshadow_meshlet_draw_commands[];
};

layout(set=CRUDE_MATERIAL_SET, binding=13) readonly buffer MeshletInstances
{
  uvec2                                                    meshletes_instances[];
};

layout(set=CRUDE_MATERIAL_SET, binding=14) buffer PointLightMeshletCount
{
  uint                                                     pointshadow_meshletes_instances_count[];
};

taskPayloadSharedEXT struct
{
  uint                                                     meshlet_indices[ 128 ];
  uint                                                     mesh_instance_draw_indices[ 128 ];
  uint                                                     light_index_face_index;
} shared_data;

void main()
{
  uint meshlete_instance_index = gl_GlobalInvocationID.x;

  uint packed_light_index_face_index = pointshadow_meshlet_draw_commands[ gl_DrawIDARB ].w;
  uint light_index = packed_light_index_face_index >> 16;

  if ( meshlete_instance_index >= pointshadow_meshletes_instances_count[ light_index ] )
  {
    return;
  }

  uvec2 packed_meshlet_instance = meshletes_instances[ light_index * CRUDE_MAX_MESHLETS_PER_LIGHT + meshlete_instance_index ];

  uint mesh_instance_index = packed_meshlet_instance.x;
  uint global_meshlet_index = packed_meshlet_instance.y;

  uint face_index = ( packed_light_index_face_index & 0xf );

  mat4 model_to_world = mesh_instance_draws[ mesh_instance_index ].model_to_world;
  vec4 world_center = vec4( meshlets[ global_meshlet_index ].center, 1 ) * model_to_world;
  float scale = max( model_to_world[ 0 ][ 0 ], max( model_to_world[ 1 ][ 1 ], model_to_world[ 2 ][ 2 ] ) );
  float radius = meshlets[ global_meshlet_index ].radius * scale * 1.1;
  vec3 cone_axis = vec3(
    int( meshlets[ global_meshlet_index ].cone_axis[ 0 ] ) / 127.f,
    int( meshlets[ global_meshlet_index ].cone_axis[ 1 ] ) / 127.f,
    int( meshlets[ global_meshlet_index ].cone_axis[ 2 ] ) / 127.f ) * mat3( model_to_world );
  float cone_cutoff = int( meshlets[ global_meshlet_index ].cone_cutoff ) / 127.f;

  const vec4 camera_sphere = pointlight_spheres[ light_index ];

  bool accept = !crude_clustered_backface_culling( world_center.xyz, radius, cone_axis, cone_cutoff, camera_sphere.xyz );

  if ( accept )
  {
    uint visible_faces = crude_get_cube_face_mask( camera_sphere.xyz, world_center.xyz - vec3( radius ), world_center.xyz + vec3( radius ) );

    switch (face_index)
    {
    case 0:
      accept = accept || ( ( visible_faces & 1 ) != 0 );
      break;
    case 1:
      accept = accept || ( ( visible_faces & 2 ) != 0 );
      break;
    case 2:
      accept = accept || ( ( visible_faces & 4 ) != 0 );
      break;
    case 3:
      accept = accept || ( ( visible_faces & 8 ) != 0 );
      break;
    case 4:
      accept = accept || ( ( visible_faces & 16 ) != 0 );
      break;
    case 5:
      accept = accept || ( ( visible_faces & 32 ) != 0 );
      break;
    }
  }

  uvec4 ballot = subgroupBallot( accept );
  uint index = subgroupBallotExclusiveBitCount( ballot );

  if ( accept )
  {
    shared_data.meshlet_indices[ index ] = global_meshlet_index;
    shared_data.mesh_instance_draw_indices[ index ] = mesh_instance_index;
  }

  uint visible_meslets_count = subgroupBallotBitCount( ballot );

  shared_data.light_index_face_index = packed_light_index_face_index;

  if ( gl_LocalInvocationID.x == 0 )
  {
    EmitMeshTasksEXT( visible_meslets_count, 1, 1 );
  }
}
