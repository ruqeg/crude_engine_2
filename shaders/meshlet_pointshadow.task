
#extension GL_EXT_mesh_shader : require
#extension GL_ARB_shader_draw_parameters : require
#extension GL_KHR_shader_subgroup_ballot: require

#ifdef CRUDE_VALIDATOR_LINTING
#include "crude/platform.glsli"
#include "crude/debug.glsli"
#include "crude/scene.glsli"
#include "crude/meshlet.glsli"
#include "crude/mesh.glsli"
#include "crude/culling.glsli"
#include "crude/light.glsli"
#endif /* CRUDE_VALIDATOR_LINTING */

layout(local_size_x=32) in;

layout(set=CRUDE_MATERIAL_SET, binding=10) readonly buffer VisibleMeshCount
{
  uint                                                     opaque_mesh_visible_count;
  uint                                                     opaque_mesh_culled_count;
  uint                                                     transparent_mesh_visible_count;
  uint                                                     transparent_mesh_culled_count;

  uint                                                     total_count;
  uint                                                     depth_pyramid_texture_index;
  uint                                                     occlusion_culling_late_flag;
  uint                                                     meshlet_index_count;

  uint                                                     dispatch_task_x;
  uint                                                     dispatch_task_y;
  uint                                                     dispatch_task_z;
  uint                                                     meshlet_instances_count;
};

layout(set=CRUDE_MATERIAL_SET, binding=11, row_major, std430) readonly buffer MeshDrawCommands
{
  crude_mesh_draw_command                                  mesh_draw_commands[];
};

layout(set=CRUDE_MATERIAL_SET, binding=12) readonly buffer ShadowCameraSpheres
{
  vec4                                                     shadow_camera_spheres[];
};

layout(set=CRUDE_MATERIAL_SET, binding=13) readonly buffer ShadowViews
{
  mat4                                                      shadow_world_to_view[];
};

layout(set=CRUDE_MATERIAL_SET, binding=14) readonly buffer MeshletDrawCommands
{
  uvec4                                                    shadow_meshlet_draw_commands[];
};

layout(set=CRUDE_MATERIAL_SET, binding=15) readonly buffer MeshletInstances
{
  uvec2                                                    shadow_meshlet_instances[];
};

layout(push_constant) uniform PushConstants
{
  uint                                                     command_read_offset;
};

taskPayloadSharedEXT struct
{
  uint                                                     meshlet_indices[ 128 ];
  uint                                                     mesh_instance_draw_indices[ 128 ];
  uint                                                     light_index_face_index;
} shared_data;

void main()
{
  uint task_index = gl_LocalInvocationID.x;

  uint meshlet_group_index = gl_WorkGroupID.x;

  uint packed_light_index_face_index = shadow_meshlet_draw_commands[ command_read_offset + gl_DrawIDARB ].w;
  uint meshlet_index = meshlet_group_index * gl_WorkGroupSize.x + task_index;
  uint light_index = packed_light_index_face_index >> 16;
  uint meshlet_index_read_offset = light_index * CRUDE_MAX_MESHLETS_PER_LIGHT;
  uint global_meshlet_index = shadow_meshlet_instances[ meshlet_index_read_offset + meshlet_index ].y;
  uint mesh_instance_index = shadow_meshlet_instances[ meshlet_index_read_offset + meshlet_index ].x;

  uint face_index = ( packed_light_index_face_index & 0xf );

  mat4 model_to_world = mesh_instance_draws[ mesh_instance_index ].model_to_world;
  vec4 world_center = vec4( meshlets[ global_meshlet_index ].center, 1 ) * model_to_world;
  float scale = max( model_to_world[ 0 ][ 0 ], max( model_to_world[ 1 ][ 1 ], model_to_world[ 2 ][ 2 ] ) );
  float radius = meshlets[ meshlet_index ].radius * scale * 1.1;
  vec3 cone_axis = vec3(
    int( meshlets[ global_meshlet_index ].cone_axis[ 0 ] ) / 127.f,
    int( meshlets[ global_meshlet_index ].cone_axis[ 1 ] ) / 127.f,
    int( meshlets[ global_meshlet_index ].cone_axis[ 2 ] ) / 127.f ) * mat3( model_to_world );
  float cone_cutoff = int( meshlets[ global_meshlet_index ].cone_cutoff ) / 127.f;

  const vec4 camera_sphere = shadow_camera_spheres[ light_index ];

  bool accept = !crude_clustered_backface_culling( world_center.xyz, radius, cone_axis, cone_cutoff, camera_sphere.xyz );

  if ( accept )
  {
    uint visible_faces = crude_get_cube_face_mask( camera_sphere.xyz, world_center.xyz - vec3( radius ), world_center.xyz + vec3( radius ) );

    switch (face_index)
    {
    case 0:
      accept = accept || ( ( visible_faces & 1 ) != 0 );
      break;
    case 1:
      accept = accept || ( ( visible_faces & 2 ) != 0 );
      break;
    case 2:
      accept = accept || ( ( visible_faces & 4 ) != 0 );
      break;
    case 3:
      accept = accept || ( ( visible_faces & 8 ) != 0 );
      break;
    case 4:
      accept = accept || ( ( visible_faces & 16 ) != 0 );
      break;
    case 5:
      accept = accept || ( ( visible_faces & 32 ) != 0 );
      break;
    }
  }

  uvec4 ballot = subgroupBallot( accept );
  uint index = subgroupBallotExclusiveBitCount( ballot );

  if ( accept )
  {
    shared_data.meshlet_indices[ index ] = global_meshlet_index;
  }

  uint visible_meslets_count = subgroupBallotBitCount( ballot );

  shared_data.light_index_face_index = packed_light_index_face_index;

  if ( task_index == 0 )
  {
    EmitMeshTasksEXT( visible_meslets_count, 1, 1 );
  }
}
