
#ifdef CRUDE_VALIDATOR_LINTING
#define CRUDE_STAGE_COMPUTE
#extension GL_GOOGLE_include_directive : enable
#include "crude/platform.glsli"
#include "crude/scene.glsli"
#include "crude/light.glsli"
#endif /* CRUDE_VALIDATOR_LINTING */

layout(local_size_x=32, local_size_y=1, local_size_z=1) in;

layout(set=CRUDE_MATERIAL_SET, binding=10) buffer PointLightMeshletCount
{
  uint                                                     pointshadow_meshletes_instances_count[];
};

layout(set=CRUDE_MATERIAL_SET, binding=11) buffer MeshletDrawCommands
{
  uvec4                                                    pointshadow_meshlet_draw_commands[];
};

void main()
{
  uint light_index = gl_GlobalInvocationID.x;
  if ( light_index >= active_lights_count )
  {
    return;
  }

  const uint visible_meshlets = pointshadow_meshletes_instances_count[ light_index ];

  if ( visible_meshlets > 0 )
  {
    const uint command_offset = atomicAdd( pointshadow_meshletes_instances_count[ CRUDE_LIGHTS_MAX_COUNT ], 4 );
    uint packed_light_index = ( light_index & 0xffff ) << 16;
    pointshadow_meshlet_draw_commands[ command_offset ] = uvec4( ( ( visible_meshlets + 31 ) / 32 ), 1, 1, packed_light_index | 0 );
    pointshadow_meshlet_draw_commands[ command_offset + 1 ] = uvec4( ( ( visible_meshlets + 31 ) / 32 ), 1, 1, packed_light_index | 1 );
    pointshadow_meshlet_draw_commands[ command_offset + 2 ] = uvec4( ( ( visible_meshlets + 31 ) / 32 ), 1, 1, packed_light_index | 2 );
    pointshadow_meshlet_draw_commands[ command_offset + 3 ] = uvec4( ( ( visible_meshlets + 31 ) / 32 ), 1, 1, packed_light_index | 3 );
  }
}