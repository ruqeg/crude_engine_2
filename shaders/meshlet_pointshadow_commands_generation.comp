
#ifdef CRUDE_VALIDATOR_LINTING
#define CRUDE_STAGE_COMPUTE
#include "crude/platform.glsli"
#include "crude/scene.glsli"
#include "crude/light.glsli"
#endif /* CRUDE_VALIDATOR_LINTING */

layout(local_size_x=32, local_size_y=1, local_size_z=1) in;

layout(set=CRUDE_MATERIAL_SET, binding=10) buffer PerLightMeshletIndices
{
  uint                                                     per_light_meshlet_instances[];
};

layout(set=CRUDE_MATERIAL_SET, binding=11) buffer MeshletDrawCommands
{
  uvec4                                                    light_meshlet_draw_commands[];
};

void main()
{
  if (gl_GlobalInvocationID.x == 0 )
  {
    per_light_meshlet_instances[ CRUDE_LIGHTS_MAX_COUNT ] = 0;
  }

  crude_global_shader_barrier( );

  uint light_index = gl_GlobalInvocationID.x;
  if ( light_index >= active_lights_count )
  {
    return;
  }

  const uint visible_meshlets = per_light_meshlet_instances[ light_index ];

  if ( visible_meshlets > 0 )
  {
    const uint command_offset = atomicAdd( per_light_meshlet_instances[ CRUDE_LIGHTS_MAX_COUNT ], 6 );
    uint packed_light_index = ( light_index & 0xffff ) << 16;
    light_meshlet_draw_commands[ command_offset ] = uvec4( ( ( visible_meshlets + 31 ) / 32 ), 1, 1, packed_light_index | 0 );
    light_meshlet_draw_commands[ command_offset + 1 ] = uvec4( ( ( visible_meshlets + 31 ) / 32 ), 1, 1, packed_light_index | 1 );
    light_meshlet_draw_commands[ command_offset + 2 ] = uvec4( ( ( visible_meshlets + 31 ) / 32 ), 1, 1, packed_light_index | 2 );
    light_meshlet_draw_commands[ command_offset + 3 ] = uvec4( ( ( visible_meshlets + 31 ) / 32 ), 1, 1, packed_light_index | 3 );
    light_meshlet_draw_commands[ command_offset + 4 ] = uvec4( ( ( visible_meshlets + 31 ) / 32 ), 1, 1, packed_light_index | 4 );
    light_meshlet_draw_commands[ command_offset + 5 ] = uvec4( ( ( visible_meshlets + 31 ) / 32 ), 1, 1, packed_light_index | 5 );
  }
}