
/* 
 * Originaly I've implemented the technique from https://www.alextardif.com/HistogramLuminance.html,
 * but for some reason atomicAdd in every thread completely fucked up my performance,
 * so I modified it a bit, I'm not sure if it work correctly, but fewer atomicAdd means less headache 
 */

#ifdef CRUDE_VALIDATOR_LINTING
#extension GL_GOOGLE_include_directive : enable
#include "crude/platform.glsli"
#endif /* CRUDE_VALIDATOR_LINTING */

layout(local_size_x=16, local_size_y=16, local_size_z=1) in;

layout(set=CRUDE_MATERIAL_SET, binding=0) writeonly buffer PackedData
{
  uint                                                    packed_data[];
};

layout( push_constant ) uniform Constants
{
	float                                                    inverse_log_lum_range;
	float                                                    min_log_lum;
  uint                                                     hdr_color_texture_index;
};

shared uint histogram_shared[ 256 ];

uint hdr_color_to_bin( vec3 color )
{
  float lum = crude_rgb_to_luminance( color );

  if ( lum < 0.005f )
  {
    return 0;
  }

  float log_lum = clamp( ( log2( lum ) - min_log_lum ) * inverse_log_lum_range, 0.0, 1.0 );
  return uint( log_lum * 254.f + 1.f );
}

void main()
{
  uint local_index = gl_LocalInvocationIndex;

  histogram_shared[ local_index ] = 0;

  barrier( );

  uvec2 hdr_color_texture_size = textureSize( global_textures[ nonuniformEXT( hdr_color_texture_index ) ], 0 ).xy;
  if ( gl_GlobalInvocationID.x < hdr_color_texture_size.x && gl_GlobalInvocationID.y < hdr_color_texture_size.y )
  {
    vec3 hdr_color = texelFetch( global_textures[ nonuniformEXT( hdr_color_texture_index ) ], ivec2( gl_GlobalInvocationID.xy ), 0 ).xyz;
    uint bin_index = hdr_color_to_bin( hdr_color );
    atomicAdd( histogram_shared[ bin_index ], 1 );
  }

  barrier( );

  uint local_count_for_this_bin = histogram_shared[ local_index ];
  uint luminance_for_this_bin = local_index;
  histogram_shared[ local_index ] = local_count_for_this_bin * luminance_for_this_bin;

  barrier( );

  /* Add all histogram_shared values to histogram_shared[0] in O(log(n)) instead of O(n) */ 
  [[unroll]]
  for ( uint cutoff = ( 256 >> 1 ); cutoff > 0; cutoff >>= 1 )
  {
    if ( uint( local_index ) < cutoff )
    {
      histogram_shared[ local_index ] += histogram_shared[ local_index + cutoff ];
    }

    barrier( );
  }

  if ( local_index == 0 )
  {
    /* Save total luminance in packed_data[ 0 ] */
    /* Save total count of darkest pixels to packed_data[ 1 ] */
    atomicAdd( packed_data[ 0 ], histogram_shared[ 0 ] );
    atomicAdd( packed_data[ 1 ], local_count_for_this_bin );
  }
}