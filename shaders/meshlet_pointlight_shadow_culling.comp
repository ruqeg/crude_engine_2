
#ifdef CRUDE_VALIDATOR_LINTING
#include "crude/platform.glsli"
#include "crude/meshlet.glsli"
#include "crude/scene.glsli"
#include "crude/light.glsli"
#include "crude/culling.glsli"
#endif /* CRUDE_VALIDATOR_LINTING */

layout(set=CRUDE_MATERIAL_SET, binding=10) buffer MeshletInstances
{
  uvec2                                                    light_meshlet_instances[];
};

layout(set=CRUDE_MATERIAL_SET, binding=11) buffer PerLightMeshletIndices
{
  uint                                                     per_light_meshlet_instances_count[];
};

layout(local_size_x=32, local_size_y=1, local_size_z=1) in;

void main()
{
  if ( gl_GlobalInvocationID.x == 0 )
  {
    for ( uint i = 0; i < CRUDE_LIGHTS_MAX_COUNT; ++i )
    {
      per_light_meshlet_instances_count[ i ] = 0;
    }
  }

  crude_global_shader_barrier( );

  uint light_index = gl_GlobalInvocationID.x % active_lights_count;
  if ( light_index >= active_lights_count )
  {
    return;
  }

  const crude_light light = lights[ light_index ];

  uint mesh_instance_index = gl_GlobalInvocationID.x / active_lights_count;
  if ( mesh_instance_index >= mesh_instances_count )
  {
    return;
  }
  
  uint mesh_draw_index = mesh_instance_draws[ mesh_instance_index ].mesh_draw_index;

  crude_mesh_draw mesh_draw = mesh_draws[ mesh_draw_index ];

  vec4 bounding_sphere = mesh_bounds[ mesh_draw_index ];
  mat4 model_to_world = mesh_instance_draws[ mesh_instance_index ].model_to_world;

  vec4 mesh_world_bounding_center = vec4( bounding_sphere.xyz, 1 ) * model_to_world;

  float scale = max( model_to_world[ 0 ][ 0 ], max( model_to_world[ 1 ][ 1 ], model_to_world[ 2 ][ 2 ] ) );
  float mesh_radius = bounding_sphere.w * scale * 1.1;

  const bool mesh_intersects_sphere = crude_sphere_intersect( mesh_world_bounding_center.xyz, mesh_radius, light.world_position, light.radius );
  if (!mesh_intersects_sphere)
  {
    return;
  }

  for ( uint i = 0; i < mesh_draw.meshletes_count; ++i )
  {
    uint meshlet_index = mesh_draw.meshletes_offset + i;
    float meshlet_radius = meshlets[ meshlet_index ].radius * scale * 1.1;
    vec4 meshlet_world_center = vec4( meshlets[ meshlet_index ].center, 1 ) * model_to_world;

    if ( crude_sphere_intersect( meshlet_world_center.xyz, meshlet_radius, light.world_position, light.radius ) )
    {
      uint offset = atomicAdd( per_light_meshlet_instances_count[ light_index ], 1 );
      light_meshlet_instances[ light_index * CRUDE_MAX_MESHLETS_PER_LIGHT + offset ] = uvec2( mesh_instance_index, meshlet_index );
    }
  }
}